---
alwaysApply: true
---

# Conventions (read alongside `docs/vision.md`)

Краткие правила для генерации и ревью кода. Детали целей, архитектуры и релизов — в `docs/vision.md`; здесь только то, что влияет на качество и что нельзя нарушать.

## Общие принципы

- **KISS и минимальные инкременты**: делаем маленькие, понятные шаги, без оверинжиниринга.
- **Следуем структуре и архитектуре** из `docs/vision.md`; не вводим новые слои/сервисы без явного обоснования.
- **Читаемый код**: ориентир на формат, совместимый с `black`; код должен быть понятен новичку.

## Обработка ошибок

- **Простые try/except**: логируй ошибку, возвращай понятное сообщение пользователю.
- **Никаких сложных retry**: в MVP не нужно автоматических повторов и сложной обработки.
- **Обработка основных ошибок**: проблемы с файлами, некорректные данные, сетевые ошибки Telegram API.
- Детали и примеры — в разделе «Подход к обработке ошибок» в `docs/vision.md`.

## Логирование

- **Стандартный Python logging**: никаких внешних библиотек.
- **Формат**: время, модуль, уровень, сообщение.
- **Логируй**: входящие сообщения, ответы бота пользователям, операции с данными (чтение/запись JSON-файлов), ошибки.
- Детали и примеры — в разделе «Подход к логгированию» в `docs/vision.md`.

## Технологический стек

- Язык: **Python**.
- Telegram: **long polling**; популярная библиотека по согласованию (фиксируется в ADR).
- Хранение: **JSON-файлы** в `data/`.
- Контейнеризация: **Docker-образ** (используется containerd); K8s-манифесты опциональны для тестов.
- Конфиг: `config.yaml`/`config.toml` + **ENV для секретов**.
- Логи: текстовые файлы в `logs/`, без внешних агрегаторов.

## Структура проекта

- Код — в `src/`. Данные — в `data/`. Документация и ADR — в `docs/`.
- Конфиги — `config.yaml`/`config.toml`; секреты — только через ENV.
- Логи — в `logs/app.log`, аудит — в `logs/audit.log`.

## Архитектура

- Сохраняем три слоя: **Telegram-адаптер → доменная логика → доступ к данным** (файлы JSON).
- Никаких прямых обращений адаптера к файлам.
- Long polling для Telegram.
- Один процесс/контейнер по умолчанию.

## Что делать ✅

- **Простые функции и минимум классов**: приоритет функциям, классы только когда действительно нужно.
- **Один файл — одна ответственность**: каждый модуль решает одну задачу.
- **Понятные имена переменных и функций**: `get_document_by_key()`, а не `get_doc()` или `doc_find()`.
- **Базовое логирование всех операций**: входящие сообщения, ответы, операции с данными, ошибки.
- **Обработка основных ошибок**: файлы, данные, доступ.
- **Документирование только API функций**: docstrings для публичных функций.
- **Готовить команды для выполнения в терминале**: сборка, запуск, остановка, диагностика

## Что НЕ делать ❌

- **Внешние БД**: PostgreSQL, Redis и т.д. — в MVP только JSON-файлы.
- **Микросервисы или сложная архитектура**: один процесс/контейнер.
- **Async/await без крайней необходимости**: используем только если библиотека Telegram требует.
- **Сложные конфиг-файлы**: `config.yaml`/`config.toml` — простые структуры, секреты в ENV.
- **Избыточные абстракции и классы**: приоритет простым функциям.
- **Полное покрытие тестами**: точечные тесты для критичной логики (парсинг, команды).
- **Сложные системы мониторинга**: простое логирование в файлы достаточно.
- **Хардкодить токены/секреты** в коде или конфигурационных файлах.
- **Обходить белые списки доступа** или ослаблять проверки.
- **Писать бизнес-логику в Telegram-адаптере** или обращаться к данным напрямую из него.
- **Менять формат JSON-файлов данных** без обновления примеров и согласованного решения (ADR/vision).
- **Не пытаться запустить команды для выполнения в терминале при подключении через ssh**: сборка, запуск, остановка, диагностика
- **Не делать коммит до подтверждения завершения итерации**

## Тесты

- Автотесты пишем **точечно под критичную логику** (парсинг, команды).
- Не требуем полного покрытия.
- Перед изменениями формата данных/команд — фиксируем решение в ADR (`docs/adr/`).
