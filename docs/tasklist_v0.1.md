# План разработки xyliganimbot MVP

## Общая информация

- **Срок разработки**: 2-3 недели (10-15 рабочих дней)
- **Длительность итерации**: 1 день
- **Принципы**: KISS, MVP-first, файловое хранилище, без БД
- **Цель**: Поиск ответов в базе знаний через Telegram-бота

---

## Итерации разработки

### Итерация 1: Настройка проекта и окружения
**День 1**

**Цель**: Создать базовую структуру проекта и настроить окружение разработки.

**Задачи**:
- [x] Создать структуру папок согласно [vision.md](vision.md)
- [x] Настроить Python окружение (venv, requirements.txt)
- [x] Создать базовые файлы: `README.md`, `.env.example`, `.gitignore`
- [x] Настроить форматирование кода (black, базовые настройки)
- [x] Создать `config.yaml.example` с примером конфигурации
- [x] Настроить базовое логирование (модуль `src/logging.py`)

**Результат**: Готовая структура проекта, настроенное окружение, можно начинать разработку.

---

### Итерация 2: Базовая интеграция с Telegram
**День 2**

**Цель**: Реализовать базовое подключение к Telegram Bot API и обработку сообщений.

**Задачи**:
- [x] Установить библиотеку `python-telegram-bot` (или `aiogram`)
- [x] Создать модуль `src/bot.py` с базовой инициализацией бота
- [x] Реализовать long polling для получения обновлений
- [x] Создать базовый обработчик сообщений (пока только логирование)
- [x] Реализовать проверку белого списка пользователей/чатов
- [x] Добавить обработку ошибок подключения к Telegram API

**Результат**: Бот подключается к Telegram, получает сообщения, проверяет белый список.

---

### Итерация 3: Модуль работы с конфигурацией
**День 3**

**Цель**: Реализовать загрузку и валидацию конфигурации.

**Задачи**:
- [x] Создать модуль `src/config.py` для работы с конфигурацией
- [x] Реализовать загрузку `config.yaml`
- [x] Реализовать загрузку переменных окружения (секреты)
- [x] Добавить валидацию обязательных параметров
- [x] Реализовать загрузку белых списков (пользователи, чаты, админы)
- [x] Добавить обработку ошибок конфигурации

**Результат**: Конфигурация загружается и валидируется при старте бота.

---

### Итерация 4: Загрузка контента из Google Docs
**День 4**

**Цель**: Реализовать загрузку контента из Google Docs и сохранение локально. Процесс независим от загрузки модели и векторизации.

**Задачи**:
- [x] Создать модуль `src/google_docs.py` для работы с Google Docs
- [x] Реализовать получение ZIP-архива с HTML и изображениями (HTTP-запрос к export?format=zip)
- [x] Реализовать распаковку ZIP-архива
- [x] Извлечение HTML-файла из архива
- [x] Извлечение изображений из архива в папку `data/images/`
- [x] Сохранение HTML в `data/knowledge.html`
- [x] Обновление ссылок на изображения в HTML (на локальные пути)
- [x] Сохранение метаданных (document_id, last_updated, images) в кэш
- [x] Добавить обработку ошибок доступа к документу и распаковки архива
- [x] Логирование операций импорта
- [x] Убрать векторизацию из процесса импорта (векторизация - отдельный процесс)

**Результат**: Модуль `src/google_docs.py` реализует загрузку контента из Google Docs и сохранение в локальные файлы (`data/knowledge.html`, `data/images/`). Процесс независим от загрузки модели и векторизации. Архитектура позволяет легко добавлять другие источники контента в будущем.

---

### Итерация 5: Обработка изображений и улучшение импорта
**День 5** ✅

**Цель**: Добавить извлечение изображений и улучшить парсинг документа.

**Задачи**:
- [x] Создать JSON-файл `data/sections.json` для хранения заголовков разделов
- [x] Добавить пример структуры файла с заголовками (массив строк)
- [x] Создать JSON-кэш с метаданными (`data/knowledge_cache.json`)
- [x] Добавить поля: `content`, `last_updated`, `document_id`, `images` (список путей к локальным файлам)
- [x] Реализовать проверку даты обновления документа
- [x] Сохранять пути к локальным изображениям в кэше
- [x] Создать структуру для связи изображений с разделами документа

**Результат**: Создана структура для хранения метаданных документа и заголовков разделов. Заголовки разделов управляются вручную через JSON-файл. Изображения хранятся локально. Реализованы функции `load_cache()`, `save_cache()`, `check_cache_needs_update()`, `get_image_paths()` в модуле `src/google_docs.py`. При импорте документа автоматически создается `data/knowledge_cache.json` с метаданными. Реализована связь изображений с разделами: добавлена функция `extract_images_from_html_section()` для извлечения путей к изображениям из HTML-разделов, расширена функция `parse_html_sections()` для возврата кортежа `(sections_content, sections_images)`. Связь изображений с разделами сохраняется в кэше в поле `section_images` (словарь: заголовок раздела -> список путей к изображениям).

---

### Итерация 6: Загрузка модели и векторизация контента
**День 6** ✅

**Цель**: Разделить на три независимых процесса: загрузка контента (уже реализована), загрузка модели, векторизация контента.

**Часть 1: Загрузка embedding-модели (независимый процесс)**

**Задачи**:
- [x] Создать модуль `src/model_loader.py` для загрузки embedding-моделей
- [x] Реализовать функцию `download_model()` для загрузки модели из HuggingFace
- [x] Реализовать сохранение модели в папку `models/` с именем модели в качестве подпапки
- [x] Добавить обработку ошибок при загрузке модели
- [x] Логирование операций загрузки модели
- [x] Обновить функцию `load_embedding_model()` в `src/search.py` для работы только с локальными моделями (без автозагрузки из HuggingFace)

**Результат**: Модуль `src/model_loader.py` реализует загрузку embedding-модели из HuggingFace и сохранение в папку `models/`. Процесс независим от загрузки контента и векторизации.

**Часть 2: Векторизация контента (независимый процесс)**

**Задачи**:
- [x] Создать модуль `src/search.py` с функциями векторизации
- [x] Реализовать загрузку заголовков разделов из `data/sections.json`
- [x] Реализовать разбиение документа на разделы (по заголовкам из JSON-файла)
- [x] Реализовать функцию `vectorize_sections()` для векторизации разделов через embedding-модель
- [x] Реализовать функцию `build_embeddings_from_html()` для построения embeddings из HTML
- [x] Реализовать `save_embeddings_to_cache()` для сохранения векторов в кэш
- [x] Реализовать `load_embeddings_from_cache()` для загрузки векторов из кэша
- [x] Убрать векторизацию из процесса импорта документа (`google_docs.py`) - векторизация должна быть отдельной командой
- [x] Создать функцию `vectorize_content()` для векторизации загруженного контента (работает с локальными файлами)
- [x] Добавить обработку ошибок при отсутствии модели или файла с заголовками
- [x] Исправить функцию `update_image_paths_in_html()` для корректной обработки file:// путей и сопоставления имен файлов

**Результат**: Векторизация контента реализована как независимый процесс, работающий с локальными файлами (`data/knowledge.html`, `data/sections.json`). Процесс не зависит от источника контента (Google Docs, Markdown и т.д.) и может быть выполнен отдельной командой после загрузки контента и модели. Векторы сохраняются в кэш (`data/knowledge_cache.json`) в формате `list[list]` для JSON-сериализации.

---

### Итерация 7: Поисковая система - семантический поиск и ранжирование
**День 7** ✅

**Цель**: Реализовать семантический поиск через косинусное сходство и ранжирование результатов.

**Задачи**:
- [x] Реализовать функцию семантического поиска `semantic_search()` для работы с векторами
- [x] Использовать `util.semantic_search()` из `sentence-transformers` для поиска
- [x] Реализовать ранжирование результатов по косинусному сходству (score 0-1)
- [x] Ограничить количество результатов (топ-3 или топ-5 наиболее релевантных)
- [x] Реализовать логику выбора цитаты: snippet (200-300 символов) или полный текст для небольших разделов (< 500 символов)
- [x] Обновить формат возвращаемых результатов: добавить `score`, `text` (цитата), `section_title`
- [x] Обновить `get_section_text()` для извлечения текста разделов (остается без изменений)
- [x] Добавить обработку случая "ничего не найдено" или низкого score (< 0.3)
- [x] Обновить `format_search_results()` в `messages.py` для отображения score и цитат
- [x] Обновить `handle_search_query()` для работы с новым форматом результатов
- [x] Обновить `bot.py` для проверки наличия модели и данных при старте (без автозагрузки)
- [x] Добавить проверки наличия необходимых данных при обработке запросов:
  - наличие embedding-модели в папке `models/` (или доступность библиотеки для fallback)
  - наличие документа в `data/knowledge.html`
  - наличие кэша с embeddings в `data/knowledge_cache.json` (проверка, что документ индексирован, токенизирован и ембедизирован)
  - наличие файла с заголовками разделов `data/sections.json`
- [x] Логирование результатов поиска (score, количество результатов)

**Результат**: Семантический поиск работает через косинусное сходство векторов. Реализована функция `search()` в модуле `src/search.py`, которая использует `util.semantic_search()` из `sentence-transformers`. Поиск ранжирует результаты по score (косинусное сходство), ограничивает результаты до топ-N наиболее релевантных разделов. Каждый результат содержит заголовок раздела, score и цитату (snippet или полный текст). Обработчики сообщений обновлены для работы с новым форматом результатов. При старте бот проверяет наличие модели и данных, но не загружает их автоматически. При обработке запросов выполняются проверки наличия необходимых данных с понятными сообщениями пользователю при их отсутствии.

---

### Итерация 8: Обработка команд и сообщений пользователей
**День 8**

**Цель**: Реализовать обработку команд и текстовых запросов пользователей.

**Задачи**:
- [x] Создать модуль `src/handlers/` с обработчиками
- [x] Реализовать обработчик команды `/help`
- [x] Реализовать обработку всех сообщений как запросов к базе знаний
- [x] Интегрировать поисковую систему с обработчиками
- [x] Реализовать отправку ответов в чат (reply на сообщение)
- [ ] Добавить отправку изображений из папки `data/images/` как файлов (photo) в Telegram-чате вместе с текстом или отдельными сообщениями

**Результат**: Бот отвечает на команды и текстовые запросы пользователей.

---

### Итерация 9: Админские команды и обновление кэша
**День 9**

**Цель**: Реализовать админские команды для управления ботом.

**Задачи**:
- [ ] Реализовать проверку прав администратора
- [ ] Реализовать команду `/admin import_content` для импорта контента из Google Docs (сохранение HTML и изображений)
- [ ] Реализовать команду `/admin load_model` для загрузки embedding-модели из HuggingFace в папку `models/` (выполняется один раз при настройке)
- [ ] Реализовать команду `/admin vectorize` для векторизации загруженного контента через embedding-модель и сохранения в кэш
- [ ] Реализовать обработку ошибок при обновлении и загрузке модели
- [ ] Добавить уведомления администратору о статусе операций
- [ ] Логирование админских операций

**Результат**: Администраторы могут управлять тремя независимыми процессами через команды:
- `/admin import_content` - загрузка контента из Google Docs
- `/admin load_model` - загрузка embedding-модели
- `/admin vectorize` - векторизация загруженного контента

Процессы независимы друг от друга и могут выполняться в любом порядке (после загрузки контента и модели можно выполнить векторизацию). Автоматическое или периодическое обновление не используется.

---

### Итерация 10: Логирование и аудит
**День 10**

**Цель**: Реализовать полноценное логирование и журнал действий.

**Задачи**:
- [ ] Расширить модуль логирования (`src/logging.py`)
- [ ] Реализовать ротацию логов по размеру файла
- [ ] Создать модуль аудита (`src/audit.py`)
- [ ] Реализовать запись в `logs/audit.log` для каждой операции
- [ ] Добавить настройку логирования текстов сообщений (по умолчанию отключено)
- [ ] Реализовать логирование всех уровней (DEBUG, INFO, WARNING, ERROR)

**Результат**: Полноценное логирование и аудит всех операций.

---

### Итерация 11: Обработка ошибок и устойчивость
**День 11**

**Цель**: Улучшить обработку ошибок и устойчивость бота.

**Задачи**:
- [ ] Реализовать централизованную обработку ошибок
- [ ] Добавить обработку всех типов ошибок (файлы, сеть, данные)
- [ ] Реализовать понятные сообщения пользователю при ошибках
- [ ] Добавить fallback на кэш при недоступности Google Docs
- [ ] Улучшить обработку сетевых ошибок Telegram API
- [ ] Добавить retry для критичных операций (опционально)

**Результат**: Бот устойчив к ошибкам, пользователи получают понятные сообщения.

---

### Итерация 12: Docker и контейнеризация
**День 12**

**Цель**: Создать Docker-образ для развертывания.

**Задачи**:
- [ ] Создать `Dockerfile` для сборки образа
- [ ] Настроить структуру для хранения embedding-моделей в папке `models/` (модели загружаются администратором вручную, не при сборке образа)
- [ ] Настроить multi-stage build (опционально) для уменьшения размера образа
- [ ] Создать `.dockerignore` (исключить модели из контекста, если они большие)
- [ ] Настроить переменные окружения в контейнере
- [ ] Протестировать сборку и запуск контейнера локально
- [ ] Проверить, что при старте контейнера выполняется проверка наличия модели (без автозагрузки)
- [ ] Обновить `README.md` с инструкциями по Docker и ручной загрузке модели

**Результат**: Готовый Docker-образ для запуска в контейнере. Embedding-модель загружается администратором вручную в папку `models/` (через volume mount или команду внутри контейнера). При старте контейнера выполняется проверка наличия модели, но автозагрузка не выполняется.

---

### Итерация 13: Kubernetes манифесты
**День 13**

**Цель**: Создать манифесты для развертывания в Kubernetes.

**Задачи**:
- [ ] Создать `k8s/namespace.yaml`
- [ ] Создать `k8s/deployment.yaml`
- [ ] Создать `k8s/service.yaml` (если требуется)
- [ ] Создать `k8s/configmap.yaml` для конфигурации
- [ ] Создать `k8s/secret.yaml.template` для секретов
- [ ] Создать `k8s/persistent-volume.yaml` и `k8s/persistent-volume-claim.yaml` для логов и кэша
- [ ] Добавить инструкции по развертыванию в `README.md`

**Результат**: Готовые манифесты для развертывания в Kubernetes.

---

### Итерация 14: Тестирование и отладка
**День 14**

**Цель**: Протестировать все функции бота и исправить найденные проблемы.

**Задачи**:
- [ ] Ручное тестирование всех команд
- [ ] Тестирование поиска с различными запросами
- [ ] Тестирование импорта документа
- [ ] Тестирование обработки ошибок
- [ ] Тестирование белых списков
- [ ] Тестирование админских команд
- [ ] Исправление найденных багов
- [ ] Проверка логирования и аудита

**Результат**: Протестированный и отлаженный бот.

---

### Итерация 15: Документация и финализация
**День 15**

**Цель**: Завершить документацию и подготовить к релизу.

**Задачи**:
- [ ] Обновить `README.md` с полными инструкциями
- [ ] Создать документацию по командам бота
- [ ] Добавить примеры конфигурации
- [ ] Создать инструкции по развертыванию через SSH
- [ ] Проверить все ссылки и примеры в документации
- [ ] Создать `CHANGELOG.md` или release notes
- [ ] Финальная проверка кода и документации

**Результат**: Полная документация, готовый к релизу MVP.
