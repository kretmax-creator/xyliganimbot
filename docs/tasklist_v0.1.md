# План разработки xyliganimbot MVP

## Общая информация

- **Срок разработки**: 2-3 недели (10-15 рабочих дней)
- **Длительность итерации**: 1 день
- **Принципы**: KISS, MVP-first, файловое хранилище, без БД
- **Цель**: Поиск ответов в базе знаний через Telegram-бота

---

## Итерации разработки

### Итерация 1: Настройка проекта и окружения
**День 1**

**Цель**: Создать базовую структуру проекта и настроить окружение разработки.

**Задачи**:
- [x] Создать структуру папок согласно [vision.md](vision.md)
- [x] Настроить Python окружение (venv, requirements.txt)
- [x] Создать базовые файлы: `README.md`, `.env.example`, `.gitignore`
- [x] Настроить форматирование кода (black, базовые настройки)
- [x] Создать `config.yaml.example` с примером конфигурации
- [x] Настроить базовое логирование (модуль `src/logging.py`)

**Результат**: Готовая структура проекта, настроенное окружение, можно начинать разработку.

---

### Итерация 2: Базовая интеграция с Telegram
**День 2**

**Цель**: Реализовать базовое подключение к Telegram Bot API и обработку сообщений.

**Задачи**:
- [x] Установить библиотеку `python-telegram-bot` (или `aiogram`)
- [x] Создать модуль `src/bot.py` с базовой инициализацией бота
- [x] Реализовать long polling для получения обновлений
- [x] Создать базовый обработчик сообщений (пока только логирование)
- [x] Реализовать проверку белого списка пользователей/чатов
- [x] Добавить обработку ошибок подключения к Telegram API

**Результат**: Бот подключается к Telegram, получает сообщения, проверяет белый список.

---

### Итерация 3: Модуль работы с конфигурацией
**День 3**

**Цель**: Реализовать загрузку и валидацию конфигурации.

**Задачи**:
- [x] Создать модуль `src/config.py` для работы с конфигурацией
- [x] Реализовать загрузку `config.yaml`
- [x] Реализовать загрузку переменных окружения (секреты)
- [x] Добавить валидацию обязательных параметров
- [x] Реализовать загрузку белых списков (пользователи, чаты, админы)
- [x] Добавить обработку ошибок конфигурации

**Результат**: Конфигурация загружается и валидируется при старте бота.

---

### Итерация 4: Импорт документа из Google Docs (базовая версия)
**День 4**

**Цель**: Реализовать базовый импорт документа из Google Docs в Markdown.

**Задачи**:
- [x] Создать модуль `src/google_docs.py`
- [x] Реализовать получение ZIP-архива с HTML и изображениями (HTTP-запрос к export?format=zip)
- [x] Реализовать распаковку ZIP-архива
- [x] Извлечение HTML-файла из архива
- [x] Извлечение изображений из архива в папку `data/images/`
- [x] Сохранение HTML в `data/knowledge.html` (или конвертация в Markdown)
- [x] Обновление ссылок на изображения в HTML/Markdown (на локальные пути)
- [x] Добавить обработку ошибок доступа к документу и распаковки архива
- [x] Логирование операций импорта

**Результат**: Бот может импортировать документ из Google Docs в виде ZIP-архива, извлекать HTML и изображения. Изображения сохраняются локально для отправки пользователям.

---

### Итерация 5: Обработка изображений и улучшение импорта
**День 5** ✅

**Цель**: Добавить извлечение изображений и улучшить парсинг документа.

**Задачи**:
- [x] Создать JSON-файл `data/sections.json` для хранения заголовков разделов
- [x] Добавить пример структуры файла с заголовками (массив строк)
- [x] Создать JSON-кэш с метаданными (`data/knowledge_cache.json`)
- [x] Добавить поля: `content`, `last_updated`, `document_id`, `images` (список путей к локальным файлам)
- [x] Реализовать проверку даты обновления документа
- [x] Сохранять пути к локальным изображениям в кэше
- [x] Создать структуру для связи изображений с разделами документа

**Результат**: Создана структура для хранения метаданных документа и заголовков разделов. Заголовки разделов управляются вручную через JSON-файл. Изображения хранятся локально. Реализованы функции `load_cache()`, `save_cache()`, `check_cache_needs_update()`, `get_image_paths()` в модуле `src/google_docs.py`. При импорте документа автоматически создается `data/knowledge_cache.json` с метаданными. Реализована связь изображений с разделами: добавлена функция `extract_images_from_html_section()` для извлечения путей к изображениям из HTML-разделов, расширена функция `parse_html_sections()` для возврата кортежа `(sections_content, sections_images)`. Связь изображений с разделами сохраняется в кэше в поле `section_images` (словарь: заголовок раздела -> список путей к изображениям).

---

### Итерация 6: Поисковая система - векторизация разделов
**День 6** ✅

**Цель**: Реализовать векторизацию разделов через embedding-модели для семантического поиска.

**Задачи**:
- [x] Создать модуль `src/search.py` с векторизацией разделов
- [x] Реализовать загрузку заголовков разделов из `data/sections.json`
- [x] Реализовать разбиение документа на разделы (по заголовкам из JSON-файла)
- [x] Добавить зависимости: `sentence-transformers`, `torch` в `requirements.txt`
- [x] Создать папку `models/` для локального хранения моделей
- [x] Реализовать функцию `load_embedding_model()` для загрузки модели из `models/`
- [x] Реализовать функцию `vectorize_sections()` для векторизации разделов через embedding-модель
- [x] Обновить `build_index_from_html()` → `build_embeddings_from_html()` для векторизации
- [x] Реализовать `save_embeddings_to_cache()` для сохранения векторов в кэш
- [x] Реализовать `load_embeddings_from_cache()` для загрузки векторов из кэша
- [x] Интегрировать векторизацию в процесс импорта документа (`google_docs.py`)
- [x] Добавить обработку ошибок при отсутствии модели или файла с заголовками
- [x] Исправить функцию `update_image_paths_in_html()` для корректной обработки file:// путей и сопоставления имен файлов

**Результат**: Разделы документа векторизуются при импорте через embedding-модель (`paraphrase-multilingual-MiniLM-L12-v2`). Векторы хранятся в кэше (`data/knowledge_cache.json`) в формате `list[list]` для JSON-сериализации. Реализованы функции: `load_embedding_model()`, `vectorize_sections()`, `build_embeddings_from_html()`, `save_embeddings_to_cache()`, `load_embeddings_from_cache()`. Модель загружается из локальной папки `models/` или из HuggingFace при первом запуске. При отсутствии библиотеки `sentence-transformers` выполняется автоматический fallback на token-based поиск. Исправлена функция обновления путей к изображениям: корректно обрабатываются file:// пути и сопоставляются имена файлов (image1.png -> image1_1.png). Все ссылки на изображения в HTML указывают на существующие файлы.

---

### Итерация 7: Поисковая система - семантический поиск и ранжирование
**День 7** ⚠️

**Цель**: Реализовать семантический поиск через косинусное сходство и ранжирование результатов.

**Задачи**:
- [ ] Реализовать функцию семантического поиска `search()` для работы с векторами
- [ ] Использовать `util.semantic_search()` из `sentence-transformers` для поиска
- [ ] Реализовать ранжирование результатов по косинусному сходству (score 0-1)
- [ ] Ограничить количество результатов (топ-3 или топ-5 наиболее релевантных)
- [ ] Реализовать логику выбора цитаты: snippet (200-300 символов) или полный текст для небольших разделов (< 500 символов)
- [ ] Обновить формат возвращаемых результатов: добавить `score`, `text` (цитата), `section_title`
- [ ] Обновить `get_section_text()` для извлечения текста разделов (остается без изменений)
- [ ] Добавить обработку случая "ничего не найдено" или низкого score (< 0.3)
- [ ] Обновить `format_search_results()` в `messages.py` для отображения score и цитат
- [ ] Обновить `handle_search_query()` для работы с новым форматом результатов
- [ ] Обновить `bot.py` для загрузки модели при старте
- [ ] Логирование результатов поиска (score, количество результатов)

**Результат**: Семантический поиск работает через косинусное сходство векторов. Реализована функция `search()` в модуле `src/search.py`, которая использует `util.semantic_search()` из `sentence-transformers`. Поиск ранжирует результаты по score (косинусное сходство), ограничивает результаты до топ-N наиболее релевантных разделов. Каждый результат содержит заголовок раздела, score и цитату (snippet или полный текст). Обработчики сообщений обновлены для работы с новым форматом результатов.

---

### Итерация 8: Обработка команд и сообщений пользователей
**День 8**

**Цель**: Реализовать обработку команд и текстовых запросов пользователей.

**Задачи**:
- [x] Создать модуль `src/handlers/` с обработчиками
- [x] Реализовать обработчик команды `/help`
- [x] Реализовать обработку всех сообщений как запросов к базе знаний
- [x] Интегрировать поисковую систему с обработчиками
- [x] Реализовать отправку ответов в чат (reply на сообщение)
- [ ] Добавить отправку изображений из папки `data/images/` как файлов (photo) в Telegram-чате вместе с текстом или отдельными сообщениями

**Результат**: Бот отвечает на команды и текстовые запросы пользователей.

---

### Итерация 9: Админские команды и обновление кэша
**День 9**

**Цель**: Реализовать админские команды для управления ботом.

**Задачи**:
- [ ] Реализовать проверку прав администратора
- [ ] Реализовать команду `/admin refresh_cache` для принудительного обновления
- [ ] Добавить периодическое обновление кэша (раз в неделю, фоновый процесс)
- [ ] Реализовать обработку ошибок при обновлении
- [ ] Добавить уведомления администратору о статусе обновления
- [ ] Логирование админских операций

**Результат**: Администраторы могут управлять обновлением базы знаний.

---

### Итерация 10: Логирование и аудит
**День 10**

**Цель**: Реализовать полноценное логирование и журнал действий.

**Задачи**:
- [ ] Расширить модуль логирования (`src/logging.py`)
- [ ] Реализовать ротацию логов по размеру файла
- [ ] Создать модуль аудита (`src/audit.py`)
- [ ] Реализовать запись в `logs/audit.log` для каждой операции
- [ ] Добавить настройку логирования текстов сообщений (по умолчанию отключено)
- [ ] Реализовать логирование всех уровней (DEBUG, INFO, WARNING, ERROR)

**Результат**: Полноценное логирование и аудит всех операций.

---

### Итерация 11: Обработка ошибок и устойчивость
**День 11**

**Цель**: Улучшить обработку ошибок и устойчивость бота.

**Задачи**:
- [ ] Реализовать централизованную обработку ошибок
- [ ] Добавить обработку всех типов ошибок (файлы, сеть, данные)
- [ ] Реализовать понятные сообщения пользователю при ошибках
- [ ] Добавить fallback на кэш при недоступности Google Docs
- [ ] Улучшить обработку сетевых ошибок Telegram API
- [ ] Добавить retry для критичных операций (опционально)

**Результат**: Бот устойчив к ошибкам, пользователи получают понятные сообщения.

---

### Итерация 12: Docker и контейнеризация
**День 12**

**Цель**: Создать Docker-образ для развертывания.

**Задачи**:
- [ ] Создать `Dockerfile` для сборки образа
- [ ] Настроить скачивание embedding-модели при сборке образа (в папку `models/`)
- [ ] Настроить multi-stage build (опционально) для уменьшения размера образа
- [ ] Создать `.dockerignore` (исключить модели из контекста, если они большие)
- [ ] Настроить переменные окружения в контейнере
- [ ] Протестировать сборку и запуск контейнера локально
- [ ] Проверить загрузку модели при старте контейнера
- [ ] Обновить `README.md` с инструкциями по Docker

**Результат**: Готовый Docker-образ с embedding-моделью, можно запускать в контейнере. Модель хранится локально в образе для автономной работы.

---

### Итерация 13: Kubernetes манифесты
**День 13**

**Цель**: Создать манифесты для развертывания в Kubernetes.

**Задачи**:
- [ ] Создать `k8s/namespace.yaml`
- [ ] Создать `k8s/deployment.yaml`
- [ ] Создать `k8s/service.yaml` (если требуется)
- [ ] Создать `k8s/configmap.yaml` для конфигурации
- [ ] Создать `k8s/secret.yaml.template` для секретов
- [ ] Создать `k8s/persistent-volume.yaml` и `k8s/persistent-volume-claim.yaml` для логов и кэша
- [ ] Добавить инструкции по развертыванию в `README.md`

**Результат**: Готовые манифесты для развертывания в Kubernetes.

---

### Итерация 14: Тестирование и отладка
**День 14**

**Цель**: Протестировать все функции бота и исправить найденные проблемы.

**Задачи**:
- [ ] Ручное тестирование всех команд
- [ ] Тестирование поиска с различными запросами
- [ ] Тестирование импорта документа
- [ ] Тестирование обработки ошибок
- [ ] Тестирование белых списков
- [ ] Тестирование админских команд
- [ ] Исправление найденных багов
- [ ] Проверка логирования и аудита

**Результат**: Протестированный и отлаженный бот.

---

### Итерация 15: Документация и финализация
**День 15**

**Цель**: Завершить документацию и подготовить к релизу.

**Задачи**:
- [ ] Обновить `README.md` с полными инструкциями
- [ ] Создать документацию по командам бота
- [ ] Добавить примеры конфигурации
- [ ] Создать инструкции по развертыванию через SSH
- [ ] Проверить все ссылки и примеры в документации
- [ ] Создать `CHANGELOG.md` или release notes
- [ ] Финальная проверка кода и документации

**Результат**: Полная документация, готовый к релизу MVP.
