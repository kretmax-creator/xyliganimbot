# Техническое видение проекта xyliganimbot

*Документ описывает техническое видение проекта для проверки идеи поиска ответов в базе знаний через Telegram-бота.*

## Технологии

Для первого релиза выбран максимально простой стек, позволяющий быстро проверить идею без оверинжиниринга.

- **Бэкенд**: Python 3.x с минимальным набором зависимостей.
- **Telegram-бот**: библиотека `python-telegram-bot` (или `aiogram`) с использованием long polling для получения обновлений.
- **Работа с Google Docs**: доступ к текстовому документу через Google Docs API или экспорт документа в текстовый формат по прямой ссылке. Для работы с API используется библиотека `google-api-python-client` с аутентификацией через сервисный аккаунт или OAuth.
- **Поиск**: простой текстовый поиск по содержимому документа (без LLM на первом этапе). LLM для улучшения ответов планируется добавить в последующих версиях.
- **Кэширование**: опциональное кэширование содержимого документа в JSON-файле с проверкой даты последнего обновления документа. Так как документ обновляется редко и имеет небольшой размер, допустимо запрашивать актуальную версию при каждом запросе или обновлять кэш при изменении документа.
- **Инфраструктура**: один Docker-контейнер, развертывание в кластере Kubernetes на трех VM с Ubuntu (на ноутбуке).

## Принцип разработки

Разработка ведётся с приоритетом простоты и быстрой проверки идеи.

- **KISS (Keep It Simple, Stupid)**: максимально простое решение без лишних абстракций и оверинжиниринга. Только самое необходимое для проверки идеи.
- **MVP-first**: реализуется только необходимый минимум для проверки идеи.
- **Файловое хранилище**: без БД на первом этапе, все данные хранятся в файлах (Markdown, JSON).
- **Допустима потеря состояния**: при перезапуске состояние не сохраняется, бот работает stateless.
- **Один чат, ограниченное число пользователей**: бот предназначен для работы в одном групповом чате с ограниченным числом пользователей.
- **Без преждевременной оптимизации**: приоритет простым решениям, оптимизация только при реальной необходимости.
- **LLM — опционально**: подключается только при явной пользе, не является частью MVP.
- **Маленькие инкрементальные шаги**: функциональность добавляется небольшими шагами, сначала базовый поиск, затем улучшения.
- **Ручное тестирование**: основной упор на тестирование через Telegram-бота. Автоматические тесты на первом этапе не требуются.
- **Простая документация**: README с инструкцией по запуску (включая команды для выполнения через SSH) и простой список команд бота. ADR создаются по необходимости для фиксации ключевых архитектурных решений.
- **Кодстайл**: код пишется с приоритетом читаемости, форматирование совместимо с `black`.

## Структура проекта

Структура проекта ориентирована на простоту и понятность расположения кода, данных и документации.

```
xyliganimbot/
├── src/              # Исходный код бота
│   ├── bot.py        # Основной модуль бота
│   ├── handlers/     # Обработчики команд и сообщений
│   ├── google_docs.py # Работа с Google Docs
│   └── search.py     # Логика поиска
├── data/             # Кэш документа (опционально)
├── logs/             # Логи приложения
├── docs/             # Документация
├── k8s/              # Kubernetes манифесты
├── tests/            # Тесты (на будущее)
├── Dockerfile        # Образ для контейнера
├── requirements.txt  # Зависимости Python
├── config.yaml       # Конфигурация (без секретов)
├── .env.example      # Пример переменных окружения
└── README.md         # Инструкции по запуску
```

- **Код приложения**: в каталоге `src/` размещается исходный код бота, обработчики команд и модули для работы с Google Docs и поиском.
- **Данные**: в каталоге `data/` хранится документ базы знаний (`knowledge.html` или `knowledge.md`), JSON-файлы с метаданными и заголовками разделов, а также папка `data/images/` для локального хранения изображений из документа.
- **Логи**: в каталоге `logs/` сохраняются логи приложения и журнал действий.
- **Документация**: в каталоге `docs/` размещаются основные документы проекта (`idea.md`, `vision.md`), ADR создаются по необходимости.
- **Конфигурация**: для конфигурации используется файл `config.yaml` в корне проекта. Секретные значения (токен Telegram-бота, учетные данные Google API) передаются через переменные окружения.
- **Контейнеризация и оркестрация**: в корне проекта располагается `Dockerfile` для сборки образа. В каталоге `k8s/` размещаются манифесты Kubernetes для развертывания в кластере.

## Архитектура проекта

Архитектура строится вокруг одного простого сервиса Telegram-бота с разделением на три логических слоя.

- **Слой интеграции с Telegram**: тонкий слой, отвечающий за приём обновлений через long polling, разбор входящих сообщений и маршрутизацию к обработчикам. Здесь не содержится бизнес-логика, только адаптация данных Telegram к внутренним моделям. На этом уровне выполняется проверка белого списка пользователей/чатов.
- **Доменный слой (логика поиска)**: отдельный модуль, в котором реализуются сценарии работы — обработка команд (например, `/help`, `/search`) и обработка всех сообщений как запросов к базе знаний. Этот слой оперирует абстракциями «запрос», «документ», «результат поиска» и обращается к модулю доступа к данным.
- **Слой доступа к данным**: модуль, инкапсулирующий работу с Google Docs API, получение содержимого документа и кэширование. Telegram-слой не знает о деталях работы с Google.

**Принципы:**
- **Один процесс/сервис**: весь функционал разворачивается как один процесс/контейнер.
- **Обработка запросов по требованию**: все действия выполняются по запросу пользователя (команды или сообщения), без фоновых задач на первом этапе.
- **Идентификация пользователей**: при обработке запросов фиксируются идентификатор и имя пользователя из Telegram для логирования и проверки доступа.

## Модель данных

Модель данных первого релиза минималистична и ориентирована на простоту.

- **База знаний**: документ из Google Docs импортируется в формате HTML (или конвертируется в Markdown) и сохраняется в `data/knowledge.html` (или `data/knowledge.md`). Один Google Doc → один HTML/Markdown-файл. Изображения из документа извлекаются из ZIP-архива экспорта и сохраняются в папке `data/images/` для последующей отправки пользователям в чате.

- **Заголовки разделов**: список заголовков разделов хранится в JSON-файле `data/sections.json` и управляется вручную. При редактировании документа базы знаний администратор также обновляет список заголовков в этом файле. Формат: массив строк с заголовками разделов в порядке их появления в документе.

- **Кэш документа** (опционально): JSON-файл в `data/knowledge_cache.json` с полями:
  - `content`: текст документа (или путь к HTML/Markdown файлу)
  - `last_updated`: дата/время последнего обновления документа в Google Docs
  - `document_id`: идентификатор документа для проверки изменений
  - `images`: массив путей к локальным файлам изображений в папке `data/images/` (опционально)

- **Журнал действий**: текстовый файл `logs/audit.log` с записями о каждой операции:
  - дата и время
  - `telegram_id`, `username` (если доступен)
  - запрос пользователя (команда или текст сообщения)
  - результат (найдено/не найдено, количество результатов, ошибки)

**Идеи на будущее:**
- История запросов пользователей (опционально, по дополнительной настройке)
- Статистика использования (популярные запросы, частота обращений)

## Работа с LLM

На первом этапе LLM не используется — реализован только простой текстовый поиск по содержимому документа.

**Планируется в будущем:**
- Использование LLM для улучшения формулировок ответов
- Понимание контекста запроса пользователя
- Генерация более развернутых ответов на основе найденной информации в документе

## Работа с Google Docs

Документ является публичным и доступен по прямой ссылке. Для чтения аутентификация не требуется.

- **Модель взаимодействия**: односторонняя модель **Google Docs → бот**. Бот работает только с локальными файлами (Markdown и JSON-кэш). Google Docs не используется в runtime, только для импорта данных.
- **Импорт документа**: получение содержимого через HTTP-запрос к прямой ссылке документа (экспорт в HTML-формат в ZIP-архиве с изображениями) или через Google Docs API с использованием сервисного аккаунта. Документ импортируется в формате HTML (или конвертируется в Markdown для удобства работы) и сохраняется в `data/knowledge.html` (или `data/knowledge.md`). Изображения извлекаются из ZIP-архива и сохраняются в папке `data/images/`. Заголовки разделов определяются не автоматически, а из отдельного JSON-файла `data/sections.json`, который управляется вручную администратором.
- **Обработка изображений**: при импорте документа изображения извлекаются из ZIP-архива экспорта Google Docs и сохраняются в папке `data/images/` с сохранением оригинальных имен файлов или генерацией уникальных идентификаторов. В ответах пользователям изображения отправляются как файлы (photo) в Telegram-чате вместе с текстовым ответом или отдельными сообщениями после текста.
- **Обновление данных**: поддерживаются два способа обновления:
  - ручной импорт по запросу администратора (через команду `/admin refresh_cache`);
  - периодический импорт (например, раз в неделю).
- **Хранение**: документ хранится в формате HTML (или Markdown) в `data/knowledge.html` (или `data/knowledge.md`). Изображения хранятся локально в папке `data/images/`. Дополнительно поддерживается JSON-кэш для быстрого доступа при поиске. Пути к локальным изображениям сохраняются в кэше.
- **Обработка ошибок**: логирование ошибок доступа к документу при импорте, возврат понятного сообщения администратору при недоступности документа. При ошибке импорта используется существующая локальная версия, если она доступна.

## Поисковая система

Поиск по базе знаний реализован с использованием простых, но эффективных подходов.

- **Обратный индекс**: для быстрого поиска по ключевым словам используется обратный индекс, построенный при импорте документа. Индекс содержит два уровня:
  - **Уровень разделов**: соответствие ключевых слов разделам документа (для быстрого определения релевантных разделов)
  - **Уровень содержимого**: индексация текста внутри каждого раздела (для точного поиска и ранжирования результатов)
  Разделение документа на разделы происходит по заголовкам из файла `data/sections.json`, который содержит список заголовков разделов, управляемый вручную администратором.
- **Ранжирование результатов**: результаты поиска ранжируются по количеству совпадений ключевых слов из запроса. Разделы с большим количеством совпадений имеют более высокий приоритет.
- **Ограничение результатов**: возвращается ограниченное количество наиболее релевантных результатов (например, 5 наиболее релевантных разделов).

## Сценарии работы (MVP)

Сценарии работы первого релиза фокусируются на поиске ответов в базе знаний.

- **Поиск в базе знаний**:
  - Пользователь отправляет сообщение (текст запроса) или обращается к боту в чате
  - Все сообщения (кроме команд) обрабатываются как запросы к базе знаний
  - Бот выполняет текстовый поиск по документу
  - Бот возвращает найденные фрагменты текста или сообщение "не найдено"
  - Если в найденном разделе есть изображения, они отправляются отдельными сообщениями после текстового ответа
  - Ответ отправляется в чат или как ответ на сообщение пользователя
  - Формат ответа: простой текст без форматирования

- **Команды**:
  - `/help` — список доступных команд и краткое описание работы бота
  - Админские команды (только для пользователей из белого списка админов):
    - `/admin refresh_cache` — принудительное обновление кэша документа из Google Docs

- **Ограничения и неподдерживаемые сценарии**:
  - Бот не ведёт диалог — каждый запрос обрабатывается независимо
  - Бот не запоминает контекст предыдущих сообщений
  - Бот не отвечает в личных сообщениях — работает только в групповых чатах из белого списка

## Деплой

Развертывание выполняется в кластере Kubernetes на трех VM с Ubuntu.

- **Docker-образ**: сборка образа из `Dockerfile`, публикация в registry (опционально, можно использовать локальный образ).
- **Kubernetes**: развертывание через манифесты в `k8s/`:
  - Deployment — основной под с ботом
  - Service — для внутреннего доступа (если потребуется)
  - ConfigMap — для конфигурации
  - Secret — для секретных данных (токен бота, учетные данные Google API)
  - PersistentVolume и PersistentVolumeClaim — для хранения логов и кэша документа
  - Namespace — отдельный namespace для изоляции приложения
- **Инструкции**: команды для выполнения через SSH на узлах кластера:
  - Создание namespace (`kubectl create namespace xyliganimbot`)
  - Применение манифестов (`kubectl apply -f k8s/`)
  - Проверка статуса (`kubectl get pods -n xyliganimbot`, `kubectl logs -n xyliganimbot`)
  - Обновление образа (`kubectl rollout restart deployment -n xyliganimbot`)
- **Конфигурация**: секретные данные через Kubernetes Secret, остальная конфигурация через ConfigMap или переменные окружения в Deployment.

## Подход к конфигурированию

Конфигурация выносится в отдельный файл и переменные окружения для простоты управления.

- **Конфигурационный файл** (`config.yaml`): основные параметры:
  - ссылка на Google Docs
  - белый список пользователей/чатов (`telegram_id`, `chat_id`)
  - белый список админов (`telegram_id`)
  - настройки логирования (уровень, путь к файлу логов)
  - интервал обновления кэша (например, раз в неделю)

- **Переменные окружения**: секретные данные:
  - `TELEGRAM_BOT_TOKEN` — токен Telegram-бота
  - `GOOGLE_SERVICE_ACCOUNT_KEY` — JSON-ключ сервисного аккаунта (если используется API)
  - другие секреты

- **Kubernetes**: ConfigMap для `config.yaml`, Secret для переменных окружения

**На начальном этапе** настройки поиска (количество результатов, минимальная длина запроса) и форматирования ответов не требуются — используется простой текстовый поиск и простой текст в ответах.

## Подход к логгированию

Логирование в первом релизе направлено на простую диагностику и понимание поведения бота.

- **Стандартный Python logging**: используется встроенный модуль `logging` без внешних библиотек.
- **Вывод логов**: запись в файл `logs/app.log` для продакшена; опционально также в консоль (`stdout`) для локальной разработки.
- **Уровни логирования**: используются уровни DEBUG, INFO, WARNING, ERROR. Уровень логирования задаётся через конфигурацию (переменная окружения `LOG_LEVEL`).
- **Формат**: время, модуль, уровень, сообщение — простой текстовый формат, удобный для чтения человеком.
- **Ротация логов**: ротация по размеру файла (например, при достижении 10MB создаётся новый файл, старые сохраняются с суффиксом номера).
- **Что логировать**:
  - **Взаимодействие с пользователями**:
    - Входящие сообщения от пользователей (команды и текстовые запросы) с указанием `telegram_id`, `chat_id`, username (уровень INFO). Тексты пользовательских сообщений отключены по умолчанию и включаются отдельной настройкой в конфигурации.
    - Ответы бота пользователям (уровень INFO).
    - Отклонённые запросы (пользователи вне белого списка, некорректные команды) (уровень WARNING).
  - **Операции с данными**:
    - Загрузка документа из Google Docs (уровень INFO).
    - Обновление кэша документа (уровень INFO).
    - Ошибки при работе с документом (уровень ERROR).
  - **Бизнес-операции**:
    - Результаты поиска (найдено/не найдено, количество результатов) (уровень INFO).
    - Критические ошибки обработки запросов (уровень ERROR).
- **Аудит**: отдельный файл `logs/audit.log` для журнала действий (как описано в модели данных), без ротации или с отдельной ротацией.

## Подход к обработке ошибок

Обработка ошибок в первом релизе строится на простых принципах: логирование всех ошибок и возврат понятных сообщений пользователю без чувствительных данных.

- **Простые try/except блоки**: используем стандартную обработку исключений Python без сложных механизмов.
- **Логирование всех ошибок**: каждая ошибка логируется с уровнем `ERROR` и контекстом (что произошло, где, с какими данными).
- **Понятные сообщения пользователю**: возвращаем короткие, понятные сообщения без технических деталей и чувствительных данных. Технические детали не раскрываются пользователю.
- **Никаких сложных retry**: в MVP не используем автоматические повторы и сложные стратегии обработки ошибок.

**Типы обрабатываемых ошибок:**
- Проблемы с файлами: файл не найден, проблемы с доступом, некорректный формат JSON/Markdown.
- Некорректные данные: неправильный формат команды, отсутствующие обязательные поля, невалидные значения.
- Сетевые ошибки Telegram API: проблемы с подключением, таймауты, ошибки API.
- Ошибки доступа к Google Docs: недоступность документа, проблемы с импортом.

