# Инструкция по ручной проверке поиска

## Вариант 1: Интерактивный скрипт

### Запуск

1. Откройте терминал в папке проекта
2. Запустите скрипт:
   ```bash
   python test_search_interactive.py
   ```

### Использование

После запуска скрипт:
- Загрузит индекс из кэша
- Распарсит разделы из HTML
- Предложит вводить запросы

**Команды:**
- Введите поисковый запрос и нажмите Enter
- `exit`, `quit` или `q` - выход
- `help` - показать справку
- `analyze <запрос>` - анализ токенов запроса

### Примеры запросов для проверки

1. **Простой запрос (1 слово):**
   ```
   токен
   пароль
   VPN
   ```

2. **Многозначный запрос:**
   ```
   токен пароль
   VPN контур
   настройка токена
   ```

3. **Запрос, которого нет:**
   ```
   несуществующий запрос xyz123
   ```

4. **Пустой запрос:**
   ```
   (просто нажмите Enter)
   ```

### Что проверять

1. **Релевантность результатов:**
   - Наиболее подходящие разделы должны быть наверху
   - Разделы с совпадениями в заголовке должны иметь больший `relevance_score`

2. **Корректность ранжирования:**
   - `relevance_score` должен убывать от первого к последнему результату
   - Разделы с совпадениями в заголовке должны быть выше разделов только с совпадениями в содержимом

3. **Ограничение результатов:**
   - Должно возвращаться максимум 5 результатов
   - Если найдено больше 5, показываются только топ-5

4. **Обработка пустых запросов:**
   - Пустой запрос должен возвращать пустой список

5. **Обработка несуществующих запросов:**
   - Запрос, которого нет в документе, должен возвращать пустой список или показывать сообщение

6. **Извлечение текста:**
   - В результатах должен быть ключ `text` с текстом раздела
   - Текст должен соответствовать содержимому раздела

---

## Вариант 2: Python REPL (интерактивная консоль)

### Запуск

1. Откройте терминал в папке проекта
2. Запустите Python:
   ```bash
   python
   ```

### Команды для выполнения

```python
# Импорт необходимых модулей
import sys
from pathlib import Path
sys.path.insert(0, str(Path.cwd()))

from src.search import load_index_from_cache, search, parse_html_sections, load_sections

# Загрузка индекса
cache_file = Path("data/knowledge_cache.json")
index = load_index_from_cache(cache_file)
print(f"Индекс загружен: {index is not None}")

# Парсинг разделов (опционально, для извлечения текста)
html_file = Path("data/knowledge.html")
sections_file = Path("data/sections.json")
sections_content = None

if html_file.exists() and sections_file.exists():
    with open(html_file, "r", encoding="utf-8") as f:
        html_content = f.read()
    sections = load_sections(sections_file)
    sections_content = parse_html_sections(html_content, sections)
    print(f"Разделов распарсено: {len(sections_content)}")

# Выполнение поиска
query = "токен"
results = search(query, index, sections_content=sections_content, limit=5)

# Анализ результатов
print(f"\nЗапрос: '{query}'")
print(f"Найдено результатов: {len(results)}")
for i, result in enumerate(results, 1):
    print(f"\n{i}. {result['section_title']}")
    print(f"   Релевантность: {result['relevance_score']}")
    print(f"   Совпадений: {result['matches']}")
    if 'text' in result:
        print(f"   Текст: {len(result['text'])} символов")
```

### Преимущества

- Быстрое тестирование разных запросов
- Возможность проверять промежуточные результаты
- Гибкость в экспериментировании

---

## Вариант 3: Расширенный тестовый скрипт

### Запуск

```bash
python test_search.py
```

Этот скрипт автоматически тестирует несколько запросов и выводит результаты.

---

## Чеклист для проверки

### Базовые проверки

- [ ] Поиск по одному слову работает
- [ ] Поиск по нескольким словам работает
- [ ] Результаты ранжируются по релевантности
- [ ] Ограничение до 5 результатов работает
- [ ] Пустой запрос обрабатывается корректно
- [ ] Несуществующий запрос обрабатывается корректно

### Проверка ранжирования

- [ ] Разделы с совпадениями в заголовке выше разделов только с совпадениями в содержимом
- [ ] `relevance_score` убывает от первого к последнему результату
- [ ] Разделы с большим количеством совпадений выше разделов с меньшим количеством

### Проверка извлечения текста

- [ ] Текст разделов извлекается корректно
- [ ] Текст соответствует содержимому раздела в HTML
- [ ] Размер текста разумный (не пустой, не слишком большой)

### Проверка производительности

- [ ] Поиск выполняется быстро (< 1 секунды для простых запросов)
- [ ] Парсинг разделов выполняется один раз (не для каждого результата)

---

## Примеры сценариев для проверки

### Сценарий 1: Точное совпадение с заголовком

**Запрос:** `токен`

**Ожидаемый результат:**
- Раздел "Токен: пароль, сертификаты" должен быть в результатах
- Если слово "токен" есть в заголовке, раздел должен иметь высокий `relevance_score`

### Сценарий 2: Поиск по содержимому

**Запрос:** `пароль`

**Ожидаемый результат:**
- Должны найтись разделы, где слово "пароль" встречается в тексте
- Разделы с "пароль" в заголовке должны быть выше

### Сценарий 3: Многозначный запрос

**Запрос:** `VPN контур`

**Ожидаемый результат:**
- Должны найтись разделы, содержащие оба слова
- Разделы с обоими словами в заголовке должны быть выше
- Разделы только с одним словом должны быть ниже

### Сценарий 4: Несуществующий запрос

**Запрос:** `xyz123abc`

**Ожидаемый результат:**
- Пустой список результатов или сообщение "ничего не найдено"

### Сценарий 5: Короткий запрос

**Запрос:** `VPN`

**Ожидаемый результат:**
- Должны найтись разделы, содержащие "VPN"
- Результаты должны быть ранжированы по релевантности

---

## Отладка проблем

### Если результаты не найдены

1. Проверьте, что индекс существует:
   ```python
   from pathlib import Path
   import json
   cache = json.load(open("data/knowledge_cache.json", "r", encoding="utf-8"))
   print("search_index" in cache)
   ```

2. Проверьте токены в запросе:
   ```python
   from src.search import tokenize_text
   tokens = tokenize_text("ваш запрос")
   print(tokens)
   ```

3. Проверьте наличие токенов в индексе:
   ```python
   index = load_index_from_cache(Path("data/knowledge_cache.json"))
   section_index = index.get("section_index", {})
   print("токен" in section_index)  # Замените "токен" на ваш токен
   ```

### Если ранжирование неправильное

1. Проверьте `relevance_score` каждого результата
2. Убедитесь, что разделы с совпадениями в заголовке имеют больший вес
3. Проверьте формулу: `relevance_score = section_matches * 2 + content_matches`

---

## Сохранение результатов проверки

Рекомендуется сохранять результаты проверки для последующего анализа:

1. Скопируйте вывод результатов поиска
2. Сохраните в файл или документ
3. Отметьте найденные проблемы
4. Зафиксируйте время выполнения поиска
